{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"java/","title":"Java","text":""},{"location":"java/fundamentals/","title":"Fundamentals","text":""},{"location":"java/fundamentals/#fundamentals","title":"Fundamentals","text":""},{"location":"java/fundamentals/control-statements/","title":"Control Statements","text":""},{"location":"java/fundamentals/control-statements/#control-flow-statements","title":"Control Flow Statements","text":""},{"location":"java/fundamentals/control-statements/#introduction","title":"Introduction","text":"<p>Control flow statements determine the order in which code executes in a program. By default, Java executes statements sequentially from top to bottom Control flow statements allow you to alter this sequential execution based on conditions, repeat code blocks, or jump to different parts of your program.</p> <p>Java provides three main categories of control flow statements:  </p> <ol> <li>Decision-Making Statements</li> <li>Looping Statements</li> <li>Jump Statements</li> </ol>"},{"location":"java/fundamentals/control-statements/#decision-making-statements","title":"Decision-Making Statements","text":"<p>Decision-Making Statements control which code blocks execute based on boolean conditions. These include <code>if</code>, <code>if-else</code>, <code>if-else-if</code> ladder, <code>nested if</code>, <code>switch</code>, and the <code>ternary operator</code>.</p>"},{"location":"java/fundamentals/control-statements/#if-statement","title":"<code>if</code> Statement","text":"<p>The simplest decision-making statement. It executes a block of code only when a specified condition evaluates to true.</p> <p>Syntax: </p><pre><code>if (condition) {\n    // code executes if condition is true\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n    B -- True --&gt; C[Execute if block]\n    C --&gt; D([End])\n    B -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int age = 18;\nif (age &gt;= 18) {\n    System.out.println(\"You are eligible to vote\");\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>The condition must be a boolean expression</li> <li>Curly braces are optional for single statements but recommended for readability</li> <li>If condition is false, the code block is skipped entirely</li> </ul>"},{"location":"java/fundamentals/control-statements/#if-else-statement","title":"<code>if-else</code> Statement","text":"<p>Provides an alternative path of execution when the condition is false.</p> <p>Syntax: </p><pre><code>if (condition) {\n    // executes if condition is true\n} else {\n    // executes if condition is false\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n    B -- True --&gt; C[Execute if block]\n    B -- False --&gt; E[Execute else block]\n    C --&gt; D([End])\n    E --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int number = 15;\nif (number % 2 == 0) {\n    System.out.println(\"Even number\");\n} else {\n    System.out.println(\"Odd number\");\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#if-else-if-ladder","title":"<code>if-else-if</code> Ladder","text":"<p>Used when you need to test multiple conditions sequentially. The first condition that evaluates to true will execute its corresponding block, and the rest will be skipped.</p> <p>Syntax: </p><pre><code>if (condition1) {\n    // executes if condition1 is true\n} else if (condition2) {\n    // executes if condition1 is false and condition2 is true\n} else if (condition3) {\n    // executes if condition1 and condition2 are false, condition3 is true\n} \n.\n.\n.\nelse {\n    // executes if all conditions are false\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition 1?}\n\n    B -- True --&gt; C[Execute Block 1]\n    B -- False --&gt; D{Condition 2?}\n\n    D -- True --&gt; E[Execute Block 2]\n    D -- False --&gt; F{Condition 3?}\n\n    F -- True --&gt; G[Execute Block 3]\n    F -- False --&gt; H[Execute Default Block]\n\n    C --&gt; I([End])\n    E --&gt; I\n    G --&gt; I\n    H --&gt; I\n</code></pre><p></p> <p>Example: </p><pre><code>int score = 85;\nif (score &gt;= 90) {\n    System.out.println(\"Grade: A\");\n} else if (score &gt;= 80) {\n    System.out.println(\"Grade: B\");\n} else if (score &gt;= 70) {\n    System.out.println(\"Grade: C\");\n} else if (score &gt;= 60) {\n    System.out.println(\"Grade: D\");\n} else {\n    System.out.println(\"Grade: F\");\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#nested-if-statements","title":"<code>Nested if</code> Statements","text":"<p>An if statement inside another if statement, used for complex decision-making scenarios.</p> <p>Syntax: </p><pre><code>if (condition1) {\n    if (condition2) {\n        // block A\n    } else {\n        // block B\n    }\n} else {\n    // block C\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition 1?}\n\n    B -- True --&gt; C{Condition 2?}\n    B -- False --&gt; H[Execute Block C]\n\n    C -- True --&gt; D[Execute Block A]\n    C -- False --&gt; E[Execute Block B]\n\n    D --&gt; F([End])\n    E --&gt; F\n    H --&gt; F\n</code></pre><p></p> <p>Example: </p><pre><code>int age = 25;\nboolean hasLicense = true;\n\nif (age &gt;= 18) {\n    if (hasLicense) {\n        System.out.println(\"You can drive\");\n    } else {\n        System.out.println(\"You need a license to drive\");\n    }\n} else {\n    System.out.println(\"You are too young to drive\");\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#switch-statement","title":"<code>switch</code> Statement","text":"<p>Provides a cleaner alternative to multiple if-else-if statements when comparing a single variable against multiple constant values.</p> <p>Syntax: </p><pre><code>switch (expression) {\n    case value1:\n        // code block\n        break;\n    case value2:\n        // code block\n        break;\n    .\n    .\n    .\n    default:\n        // code block\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Evaluate Expression]\n    B --&gt; C{Match Case 1?}\n\n    C -- Yes --&gt; D[Execute Block 1]\n    C -- No --&gt; E{Match Case 2?}\n\n    E -- Yes --&gt; F[Execute Block 2]\n    E -- No --&gt; G{Match Case 3?}\n\n    G -- Yes --&gt; H[Execute Block 3]\n    G -- No --&gt; I[Execute Default Block]\n\n    D --&gt; J([End])\n    F --&gt; J\n    H --&gt; J\n    I --&gt; J\n</code></pre><p></p> <p>Example: </p><pre><code>int day = 3;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    case 4:\n        System.out.println(\"Thursday\");\n        break;\n    case 5:\n        System.out.println(\"Friday\");\n        break;\n    case 6:\n        System.out.println(\"Saturday\");\n        break;\n    case 7:\n        System.out.println(\"Sunday\");\n        break;\n    default:\n        System.out.println(\"Invalid day\");\n}\n</code></pre><p></p> <p>Advanced switch Features (Java 12+): Java 12 introduced switch expressions with arrow syntax: </p><pre><code>String day = switch (dayNumber) {\n    case 1 -&gt; \"Monday\";\n    case 2 -&gt; \"Tuesday\";\n    case 3 -&gt; \"Wednesday\";\n    case 4 -&gt; \"Thursday\";\n    case 5 -&gt; \"Friday\";\n    case 6, 7 -&gt; \"Weekend\";\n    default -&gt; \"Invalid\";\n};\n</code></pre><p></p> <p>Important switch Concepts:</p> <ul> <li>Switch works with <code>byte</code>, <code>short</code>, <code>int</code>, <code>char</code>, <code>String</code> (Java 7+), and <code>enum</code> types</li> <li>The <code>break</code> statement is crucial to prevent fall-through behavior</li> <li>Fall-through occurs when <code>break</code> is omitted, causing execution to continue into the next case</li> <li>The <code>default</code> case is optional but recommended for handling unexpected values</li> <li>Multiple cases can share the same code block</li> </ul> <p>Example of Intentional Fall-through: </p><pre><code>int month = 2;\nint days;\nswitch (month) {\n    case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n        days = 31;\n        break;\n    case 4: case 6: case 9: case 11:\n        days = 30;\n        break;\n    case 2:\n        days = 28;\n        break;\n    default:\n        days = 0;\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#ternary-operator","title":"Ternary Operator","text":"<p>A concise way to write simple if-else statements in a single line.</p> <p>Syntax: </p><pre><code>variable = (condition) ? expressionIfTrue : expressionIfFalse;\n</code></pre><p></p> <p>Example: </p><pre><code>int a = 10, b = 20;\nint max = (a &gt; b) ? a : b;\nSystem.out.println(\"Maximum: \" + max);\n\n// Can be nested (not recommended for readability)\nint x = 5;\nString result = (x &gt; 0) ? \"Positive\" : (x &lt; 0) ? \"Negative\" : \"Zero\";\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#looping-statements","title":"Looping Statements","text":"<p>Looping Statements execute code blocks repeatedly based on conditions. Java provides <code>for</code> loop, <code>while</code> loop, <code>do-while</code> loop, and enhanced <code>for-each</code> loop.</p>"},{"location":"java/fundamentals/control-statements/#for-loop","title":"<code>for</code> Loop","text":"<p>Used when you know in advance how many times you want to execute a block of code.</p> <p>Syntax: </p><pre><code>for (initialization; condition; update) {\n    // code to be executed\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Initialization]\n    B --&gt; C{Condition?}\n\n    C -- True --&gt; D[Execute Loop Body]\n    D --&gt; E[Update Expression]\n    E --&gt; C\n\n    C -- False --&gt; F([End])\n</code></pre><p></p> <p>Execution Flow:</p> <ol> <li>Initialization executes once at the beginning</li> <li>Condition is evaluated before each iteration</li> <li>If condition is true, loop body executes</li> <li>Update statement executes after each iteration</li> <li>Process repeats from step 2</li> </ol> <p>Example: </p><pre><code>for (int i = 0; i &lt; 5; i++) {\n    System.out.println(\"Iteration: \" + i);\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#while-loop","title":"<code>while</code> Loop","text":"<p>Executes a block of code as long as a specified condition remains true. Best used when the number of iterations is unknown.</p> <p>Syntax: </p><pre><code>while (condition) {\n    // code to be executed\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n\n    B -- True --&gt; C[Execute Loop Body]\n    C --&gt; B\n\n    B -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int count = 1;\nwhile (count &lt;= 5) {\n    System.out.println(\"Count: \" + count);\n    count++;\n}\n\n// Reading input until a sentinel value\nScanner scanner = new Scanner(System.in);\nint number = scanner.nextInt();\nwhile (number != -1) {\n    System.out.println(\"You entered: \" + number);\n    number = scanner.nextInt();\n}\n</code></pre><p></p> <p>Important Considerations:</p> <ul> <li>The condition is checked before the loop body executes</li> <li>If the condition is initially false, the loop body never executes</li> <li>Must ensure the condition eventually becomes false to avoid infinite loops</li> </ul>"},{"location":"java/fundamentals/control-statements/#do-while-loop","title":"<code>do-while</code> Loop","text":"<p>Similar to while loop but guarantees at least one execution because the condition is checked after the loop body.</p> <p>Syntax: </p><pre><code>do {\n    // code to be executed\n} while (condition);\n</code></pre><p></p> <p>Flow Chart </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Execute Loop Body]\n    B --&gt; C{Condition?}\n\n    C -- True --&gt; B\n    C -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int number;\nScanner scanner = new Scanner(System.in);\ndo {\n    System.out.print(\"Enter a positive number: \");\n    number = scanner.nextInt();\n} while (number &lt;= 0);\n\n// Menu-driven program example\nint choice;\ndo {\n    System.out.println(\"1. Option A\");\n    System.out.println(\"2. Option B\");\n    System.out.println(\"3. Exit\");\n    choice = scanner.nextInt();\n    // process choice\n} while (choice != 3);\n</code></pre><p></p> <p>Key Difference from <code>while</code>:</p> <ul> <li><code>do-while</code> executes at least once regardless of condition</li> <li><code>while</code> may not execute at all if condition is initially false</li> </ul>"},{"location":"java/fundamentals/control-statements/#enhanced-for-loop-for-each","title":"Enhanced for Loop (<code>for-each</code>)","text":"<p>Introduced in Java 5, this loop simplifies iteration over arrays and collections.</p> <p>Syntax: </p><pre><code>for (dataType variable : arrayOrCollection) {\n    // code using variable\n}\n</code></pre><p></p> <p>Example: </p><pre><code>int[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) {\n    System.out.println(num);\n}\n\n// With collections\nList&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nfor (String name : names) {\n    System.out.println(name);\n}\n</code></pre><p></p> <p>Limitations:</p> <ul> <li>Cannot modify the array elements (modifications won't affect the original array)</li> <li>Cannot track the index while iterating</li> <li>Can only iterate forward in single steps</li> <li>Cannot iterate over multiple arrays simultaneously</li> </ul>"},{"location":"java/fundamentals/control-statements/#jump-statements","title":"Jump Statements","text":"<p>Jump Statements alter the normal flow of control by transferring execution to another part of the program. These include <code>break</code>, <code>continue</code>, and <code>return</code>.</p>"},{"location":"java/fundamentals/control-statements/#break-statement","title":"<code>break</code> Statement","text":"<p>Terminates the loop or switch statement and transfers control to the statement immediately following the loop or switch.</p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TB\n    A([Start]) --&gt; B{Loop Condition?}\n\n    B -- True --&gt; C{Break Condition?}\n    C -- Yes --&gt; F([Exit Loop])\n    C -- No --&gt; D[Execute Remaining Loop Body]\n    D --&gt; B\n\n    B -- False --&gt; F\n</code></pre><p></p> <p>Usage Scenarios: </p><pre><code>// Breaking out of a loop\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i == 5) {\n        break;  // exits loop when i is 5\n    }\n    System.out.println(i);\n}\n// Output: 1 2 3 4\n\n// Breaking from nested loops using labels\nouterLoop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i == 2 &amp;&amp; j == 2) {\n            break outerLoop;  // breaks from outer loop\n        }\n        System.out.println(i + \" \" + j);\n    }\n}\n\n// Searching in an array\nint[] numbers = {5, 2, 8, 1, 9};\nint target = 8;\nboolean found = false;\nfor (int num : numbers) {\n    if (num == target) {\n        found = true;\n        break;\n    }\n}\n</code></pre><p></p> <ul> <li>If <code>break</code> condition becomes true \u2192 loop terminates immediately.</li> <li>Control moves outside the loop.</li> </ul>"},{"location":"java/fundamentals/control-statements/#continue-statement","title":"<code>continue</code> Statement","text":"<p>Skips the current iteration of a loop and proceeds to the next iteration.</p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\nflowchart TD\n    A([Start]) --&gt; B{Loop Condition?}\n\n    B -- True --&gt; C{Continue Condition?}\n    C -- Yes --&gt; B\n    C -- No --&gt; D[Execute Remaining Loop Body]\n    D --&gt; B\n\n    B -- False --&gt; E([End])\n</code></pre><p></p> <p>Example: </p><pre><code>// Skip even numbers\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i % 2 == 0) {\n        continue;  // skips even numbers\n    }\n    System.out.println(i);\n}\n// Output: 1 3 5 7 9\n\n// With labels in nested loops\nouterLoop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) {\n            continue outerLoop;  // continues outer loop\n        }\n        System.out.println(i + \" \" + j);\n    }\n}\n</code></pre><p></p> <ul> <li>If <code>continue</code> condition is true \u2192 skip remaining statements</li> <li>Control jumps to next iteration</li> <li>Loop does NOT terminate</li> </ul>"},{"location":"java/fundamentals/control-statements/#return-statement","title":"<code>return</code> Statement","text":"<p>Exits from the current method and optionally returns a value to the calling method.</p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\nflowchart TD\n    A([Method Start]) --&gt; B{Condition?}\n\n    B -- True --&gt; C[Return Value]\n    B -- False --&gt; D[Another Return Value]\n\n    C --&gt; E([Method End])\n    D --&gt; E\n</code></pre><p></p> <p>Example: </p><pre><code>public int findMax(int[] array) {\n    if (array == null || array.length == 0) {\n        return -1;  // early return for invalid input\n    }\n\n    int max = array[0];\n    for (int i = 1; i &lt; array.length; i++) {\n        if (array[i] &gt; max) {\n            max = array[i];\n        }\n    }\n    return max;\n}\n\npublic void printPositiveNumbers(int[] numbers) {\n    for (int num : numbers) {\n        if (num &lt; 0) {\n            return;  // exits method immediately\n        }\n        System.out.println(num);\n    }\n}\n</code></pre><p></p> <ul> <li><code>return</code> immediately exits the method</li> <li>Control goes back to the caller</li> <li>No further code executes in that method</li> </ul>"},{"location":"java/fundamentals/control-statements/#best-practices","title":"Best Practices","text":"<ol> <li>Always use braces for if/else and loops, even for single statements, to prevent bugs during maintenance.</li> <li>Avoid deep nesting of <code>if</code> statements. Consider refactoring into separate methods or using early returns.</li> <li>Use meaningful conditions and avoid magic numbers: <pre><code>   // Bad\nif (status == 1) { }\n\n// Good\nfinal int ACTIVE = 1;\nif (status == ACTIVE) { }\n</code></pre></li> <li>Choose the right loop based on your needs. Use <code>for</code> when iterations are known, <code>while</code> when they depend on conditions, and <code>for-each</code> for simple traversal.</li> <li>Be cautious with infinite loops and always ensure a proper exit condition.</li> </ol>"},{"location":"java/fundamentals/control-statements/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Forgetting break in switch statements leads to fall-through behavior: <pre><code>// Bug: will print multiple days\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n    case 2:\n        System.out.println(\"Tuesday\");  // executes even when day is 1\n}\n</code></pre></li> <li>Using assignment instead of comparison: <pre><code>if (x = 5) { }  // Compilation error in Java (good!)\n</code></pre></li> <li>Off-by-one errors in loops: <pre><code>// Bug: misses last element\nfor (int i = 0; i &lt; array.length - 1; i++) { }\n\n// Correct\nfor (int i = 0; i &lt; array.length; i++) { }\n</code></pre></li> <li>Modifying loop variables incorrectly: <pre><code>// Bug: infinite loop\nfor (int i = 0; i &lt; 10; i--) { }\n</code></pre></li> <li>Comparing strings with == instead of equals(): <pre><code>// Wrong\nif (str == \"hello\") { }\n\n// Correct\nif (str.equals(\"hello\")) { }\n</code></pre></li> </ol>"},{"location":"java/fundamentals/control-statements/#performance-considerations","title":"Performance Considerations","text":"<p>The choice between different control structures can impact performance. <code>for-each</code> loops are generally as fast as traditional <code>for</code> loops. <code>Switch</code> statements with many cases can be optimized by the JVM into jump tables, making them faster than equivalent <code>if-else</code> chains for certain scenarios.</p>"},{"location":"java/oops/","title":"OOPs","text":""},{"location":"java/oops/#object-oriented-programming-oop","title":"Object-Oriented Programming (OOP)","text":""},{"location":"java/oops/classes-and-objects/","title":"Classes and Objects","text":""},{"location":"java/strings/basics/","title":"Basics","text":""},{"location":"java/strings/basics/#strings-in-java","title":"Strings in Java","text":""},{"location":"java/strings/basics/#introduction","title":"Introduction","text":"<p>In Java, <code>String</code> is one of the most fundamental and widely used classes, representing an immutable sequence of characters. Unlike primitive types, <code>String</code> is a reference type that provides powerful methods for text manipulation, comparison, and transformation. Strings are ubiquitous in Java applications\u2014from user input and file I/O to network communication and data serialization.</p> <p>Understanding <code>String</code> deeply is crucial for Java developers because it impacts code correctness, performance, and memory efficiency. The immutability of strings, the string pool optimization, and the distinction between <code>String</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> are key concepts.</p>"},{"location":"java/strings/basics/#creating-strings","title":"Creating Strings","text":"<p>There are multiple ways to create <code>String</code> objects in Java:</p> <ol> <li> <p>String Literals </p><pre><code>String s1 = \"Hello\";\nString s2 = \"Hello\";\n// s1 == s2 is true (same reference in string pool)\n</code></pre><p></p> </li> <li> <p>Using <code>new</code> Keyword </p><pre><code>String s3 = new String(\"Hello\");\nString s4 = new String(\"Hello\");\n// s3 == s4 is false (different objects)\n// s3.equals(s4) is true (same content) \n</code></pre><p></p> </li> <li> <p>Using <code>String.valueOf()</code> </p><pre><code>int num = 123;\nString s5 = String.valueOf(num);  // \"123\"\nString s6 = String.valueOf(true); // \"true\"\nString s7 = String.valueOf(3.14); // \"3.14\"\n</code></pre><p></p> </li> <li> <p>Using <code>String.format()</code> </p><pre><code>String s8 = String.format(\"Name: %s, Age: %d\", \"Alice\", 25);\n// \"Name: Alice, Age: 25\"\n</code></pre><p></p> </li> <li> <p>Text Blocks (Java 15+) </p><pre><code>String json = \"\"\"\n    {\n        \"name\": \"Alice\",\n        \"age\": 25\n    }\n    \"\"\";\n</code></pre><p></p> </li> </ol>"},{"location":"java/strings/basics/#string-pool-intern","title":"String Pool &amp; <code>intern()</code>","text":"<p>The <code>String Pool</code> (or String Intern Pool) is a special memory region in the Java heap where string literals are stored. When you create a string literal, the JVM checks if an identical string already exists in the pool. If it does, the JVM returns a reference to the existing string instead of creating a new object.</p> <p>Example with <code>intern()</code>: </p><pre><code>String s1 = \"Hello\";           // In string pool\nString s2 = new String(\"Hello\"); // In heap (not pool)\nString s3 = s2.intern();       // Returns reference from pool\n\nSystem.out.println(s1 == s2);  // false (different objects)\nSystem.out.println(s1 == s3);  // true (same pool reference)\nSystem.out.println(s1.equals(s2)); // true (same content)\n</code></pre><p></p> <p>Memory Layout Visualization: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart LR\n\n    subgraph Stack Memory\n        S1[s1]\n        S2[s2]\n        S3[s3]\n    end\n\n    subgraph Heap Memory\n        subgraph String Constant Pool\n            P[\"Hello (pooled object)\"]\n        end\n\n        H[\"Hello (new object)\"]\n    end\n\n    S1 --&gt; P\n    S2 --&gt; H\n    S3 --&gt; P\n\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>String literals are automatically interned</li> <li><code>new String()</code> creates a new object on the heap</li> <li><code>intern()</code> returns the canonical representation from the pool</li> <li>Use literals when possible to leverage the pool</li> </ul>"},{"location":"java/strings/immutability/","title":"Immutability","text":""},{"location":"java/strings/immutability/#strings-immutability","title":"Strings Immutability","text":""},{"location":"java/strings/immutability/#what-is-immutability","title":"What is Immutability?","text":"<p>Immutability means that once a <code>String</code> object is created, its internal state (the character sequence it holds) cannot be changed. Any operation that appears to modify a string actually creates a new String object with the modified content, leaving the original untouched.</p> <pre><code>String str = \"Hello\";\nstr.concat(\" World\");  // Creates new String, but str still points to \"Hello\"\nSystem.out.println(str);  // Output: \"Hello\" (unchanged!)\n\nString newStr = str.concat(\" World\");  // Must capture the new object\nSystem.out.println(newStr);  // Output: \"Hello World\"\n</code></pre>"},{"location":"java/strings/immutability/#internal-implementation","title":"Internal Implementation","text":"<p>Internally, a <code>String</code> is backed by a character array. Here's a simplified view of the <code>String</code> class:</p> <pre><code>public final class String {\n    private final char[] value;  // Java 8 and earlier\n    // Or: private final byte[] value; // Java 9+ (compact strings)\n\n    private final int hash;  // Cached hashcode\n\n    // No setter methods!\n    // All methods that \"modify\" return new String objects\n}\n</code></pre> <p>Key points:</p> <ul> <li>The <code>value</code> array is <code>private final</code> - it can't be reassigned after initialization</li> <li>The <code>String</code> class is <code>final</code> - can't be subclassed to add mutable behavior</li> <li>No public methods exist to modify the internal character array</li> </ul>"},{"location":"java/strings/immutability/#why-are-strings-immutable","title":"Why Are Strings Immutable?","text":""},{"location":"java/strings/immutability/#1-string-pool-memory-optimization","title":"1. String Pool (Memory Optimization)","text":"<p>The JVM maintains a String Pool where identical string literals are reused:</p> <pre><code>String s1 = \"Java\";\nString s2 = \"Java\";\nString s3 = \"Java\";\n\n// All three variables point to THE SAME object in memory\nSystem.out.println(s1 == s2);  // true\nSystem.out.println(s2 == s3);  // true\n</code></pre> <p>Memory layout: </p><pre><code>flowchart LR\n\n    %% Stack Variables\n    subgraph Stack\n        S1[s1]\n        S2[s2]\n        S3[s3]\n    end\n\n    %% Heap - String Pool\n    subgraph Heap Memory\n        subgraph String Pool\n            J[\"Java @ 0x100\"]\n        end\n    end\n\n    S1 --&gt; J\n    S2 --&gt; J\n    S3 --&gt; J\n</code></pre><p></p> <p>If strings were mutable, changing <code>s1</code> would affect <code>s2</code> and <code>s3</code> - a nightmare! Immutability makes this safe sharing possible, saving memory.</p>"},{"location":"java/strings/immutability/#2-security","title":"2. Security","text":"<p>Strings are used for sensitive data like:</p> <ul> <li>File paths</li> <li>Network connections</li> <li>Database queries</li> <li>User credentials</li> </ul> <p>Security scenario: </p><pre><code>String password = \"secret123\";\n\nif (authenticate(password)) {\n    // Without immutability, password could be changed here\n    // by reference manipulation from malicious code\n    grantAccess();  // We know password hasn't changed\n}\n</code></pre><p></p>"},{"location":"java/strings/immutability/#3-thread-safety","title":"3. Thread Safety","text":"<p>Immutable objects are inherently thread-safe - no synchronization needed! </p><pre><code>public class ThreadSafeExample {\n    private String sharedString = \"Shared Data\";\n\n    // Multiple threads can read this safely without locks\n    public String getData() {\n        return sharedString;  // No synchronization needed!\n    }\n}\n</code></pre><p></p> <p>Compare with mutable alternative: </p><pre><code>public class NotThreadSafe {\n    private StringBuilder mutableString = new StringBuilder(\"Data\");\n\n    // REQUIRES synchronization to be safe\n    public synchronized String getData() {\n        return mutableString.toString();\n    }\n\n    public synchronized void setData(String data) {\n        mutableString.setLength(0);\n        mutableString.append(data);\n    }\n}\n</code></pre><p></p>"},{"location":"java/strings/immutability/#4-hashcode-caching","title":"4. Hashcode Caching","text":"<p>Since strings can't change, their hashcode can be computed once and cached: </p><pre><code>public final class String {\n    private int hash;  // Default to 0\n\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 &amp;&amp; value.length &gt; 0) {\n            // Compute only once\n            h = calculateHash();\n            hash = h;\n        }\n        return h;\n    }\n}\n</code></pre><p></p> <p>This makes strings extremely efficient as HashMap/HashSet keys: </p><pre><code>Map&lt;String, User&gt; userCache = new HashMap&lt;&gt;();\nuserCache.put(\"john@email.com\", johnUser);  // hashCode computed once\n\n// Later lookups are very fast - no hash recomputation\nUser john = userCache.get(\"john@email.com\");\n</code></pre><p></p>"},{"location":"java/strings/immutability/#5-class-loading","title":"5. Class Loading","text":"<p>Class and method names are strings. Immutability prevents security issues: </p><pre><code>String className = \"com.example.TrustedClass\";\nClass&lt;?&gt; cla = Class.forName(className);\n// If String were mutable, className could be changed to load malicious code!\n</code></pre><p></p>"},{"location":"java/strings/immutability/#demonstrating-immutability","title":"Demonstrating Immutability","text":"<p>Example 1: Concatenation Creates New Objects </p><pre><code>String original = \"Hello\";\nString modified = original + \" World\";\n\nSystem.out.println(original);   // \"Hello\" (unchanged)\nSystem.out.println(modified);   // \"Hello World\" (new object)\nSystem.out.println(original == modified);  // false (different objects)\n</code></pre><p></p> <p>Memory layout: </p><pre><code>flowchart LR\n\n    %% Stack Section\n    subgraph Stack\n        O[original]\n        M[modified]\n    end\n\n    %% Heap Section\n    subgraph Heap Memory\n        subgraph String Pool\n            H[\"Hello\"]\n            W[\" World\"]\n        end\n\n        HW[\"Hello World\"]\n    end\n\n    O --&gt; H\n    M --&gt; HW\n\n</code></pre><p></p> <p>Example 2: String Methods Return New Strings </p><pre><code>String s = \"  Java Programming  \";\n\nString trimmed = s.trim();\nString upper = s.toUpperCase();\nString replaced = s.replace(\"Java\", \"Python\");\n\nSystem.out.println(s);         // \"  Java Programming  \" (UNCHANGED)\nSystem.out.println(trimmed);   // \"Java Programming\"\nSystem.out.println(upper);     // \"  JAVA PROGRAMMING  \"\nSystem.out.println(replaced);  // \"  Python Programming  \"\n</code></pre><p></p> <p>Example 3: Even Array Manipulation Doesn't Change Original </p><pre><code>String str = \"Hello\";\nchar[] chars = str.toCharArray();  // Creates a COPY\n\nchars[0] = 'J';  // Modify the array\n\nSystem.out.println(str);           // \"Hello\" (unchanged!)\nSystem.out.println(new String(chars));  // \"Jello\"\n</code></pre><p></p> <p>Example 4: Reflection Can't Mutate (Well, Almost...) Warning: This is a demonstration of Java internals - NEVER do this in production!</p> <pre><code>String s = \"Hello\";\n\n// Using reflection to access private fields (VERY BAD PRACTICE)\nField valueField = String.class.getDeclaredField(\"value\");\nvalueField.setAccessible(true);\nchar[] value = (char[]) valueField.get(s);\nvalue[0] = 'J';\n\nSystem.out.println(s);  // \"Jello\" (CORRUPTED!)\n\n// This breaks the String pool:\nString s2 = \"Hello\";\nSystem.out.println(s2);  // \"Jello\" (WRONG! Pool is corrupted)\n</code></pre> <p>This demonstrates why the <code>value</code> field is private and why you should never use reflection to modify strings!</p>"},{"location":"java/strings/immutability/#performance-implications","title":"Performance Implications","text":"<p>The Cost of Immutability Problem: String concatenation in loops </p><pre><code>// \u274c VERY INEFFICIENT: O(n\u00b2) complexity\nString result = \"\";\nfor (int i = 0; i &lt; 10000; i++) {\n    result += i + \",\";  // Creates 10,000 intermediate String objects!\n}\n</code></pre><p></p> <p>What happens:</p> <ol> <li>Iteration 1: <code>\"\" + \"0,\"</code> \u2192 new String <code>\"0,\"</code></li> <li>Iteration 2: <code>\"0,\" + \"1,\"</code> \u2192 new String <code>\"0,1,\"</code> (copies \"0,\")</li> <li>Iteration 3: <code>\"0,1,\" + \"2,\"</code> \u2192 new String <code>\"0,1,2,\"</code> (copies \"0,1,\")</li> <li>And so on...</li> </ol> <p>Memory created: </p><pre><code>\"\"\n\"0,\"\n\"0,1,\"\n\"0,1,2,\"\n\"0,1,2,3,\"\n...\n</code></pre> Total characters copied: <code>0 + 2 + 4 + 6 + ... \u2248 n\u00b2/2</code><p></p> <p>The Solution: <code>StringBuilder</code> </p><pre><code>// \u2705 EFFICIENT: O(n) complexity\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 10000; i++) {\n    sb.append(i).append(\",\");\n}\nString result = sb.toString();  // Only ONE String object created at the end\n</code></pre><p></p> <p>How StringBuilder works:</p> <ul> <li>Maintains a mutable character array</li> <li>When capacity is exceeded, creates a larger array and copies</li> <li>Only creates a String when you call toString()</li> </ul>"},{"location":"java/strings/immutability/#compiler-optimizations","title":"Compiler Optimizations","text":"<p>Compile-Time Concatenation The compiler is smart about string literals </p><pre><code>// This code:\nString s = \"Hello\" + \" \" + \"World\";\n\n// Is compiled to:\nString s = \"Hello World\";  // Single literal, no concatenation!\n</code></pre><p></p> <p>Runtime Concatenation (Java 9+) For runtime concatenation, modern Java uses <code>invokedynamic</code>: </p><pre><code>String name = \"Alice\";\nString greeting = \"Hello, \" + name + \"!\";\n\n// Pre-Java 9: Compiled to StringBuilder\nStringBuilder temp = new StringBuilder();\ntemp.append(\"Hello, \").append(name).append(\"!\");\nString greeting = temp.toString();\n\n// Java 9+: Uses invokedynamic with StringConcatFactory\n// More efficient, JVM can optimize further\n</code></pre><p></p>"},{"location":"java/strings/immutability/#best-practices","title":"Best Practices","text":"<p>1. Embrace Immutability for Single Operations </p><pre><code>// \u2705 Fine for single operations\nString result = str.toUpperCase().trim().replace(\" \", \"_\");\n</code></pre><p></p> <p>2. Use StringBuilder for Multiple Modifications </p><pre><code>// \u2705 When building strings in loops\nStringBuilder builder = new StringBuilder();\nfor (Item item : items) {\n    builder.append(item.getName()).append(\", \");\n}\n</code></pre><p></p> <p>3. Leverage the String Pool </p><pre><code>// \u2705 Use literals\nString s1 = \"constant\";\n\n// \u274c Avoid unnecessary object creation\nString s2 = new String(\"constant\");  // Creates extra object!\n</code></pre><p></p> <p>4. Don't Fear Immutability </p><pre><code>// This is FINE - Java optimizes it\nString fileName = basePath + \"/\" + folder + \"/\" + file;\n\n// This is the PROBLEM - loop concatenation\nString csv = \"\";\nfor (int i = 0; i &lt; 10000; i++) {\n    csv += i + \",\";  // \u274c\n}\n</code></pre><p></p>"},{"location":"java/strings/string-comparison/","title":"== VS equlas()","text":""}]}