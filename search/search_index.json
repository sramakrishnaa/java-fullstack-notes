{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"java/","title":"Java","text":""},{"location":"java/fundamentals/","title":"Fundamentals","text":""},{"location":"java/fundamentals/#fundamentals","title":"Fundamentals","text":""},{"location":"java/fundamentals/control-statements/","title":"Control Flow Statements","text":""},{"location":"java/fundamentals/control-statements/#control-flow-statements","title":"Control Flow Statements","text":""},{"location":"java/fundamentals/control-statements/#introduction","title":"Introduction","text":"<p>Control flow statements determine the order in which code executes in a program. By default, Java executes statements sequentially from top to bottom Control flow statements allow you to alter this sequential execution based on conditions, repeat code blocks, or jump to different parts of your program.</p> <p>Java provides three main categories of control flow statements:  </p> <ol> <li>Decision-Making Statements</li> <li>Looping Statements</li> <li>Jump Statements</li> </ol>"},{"location":"java/fundamentals/control-statements/#decision-making-statements","title":"Decision-Making Statements","text":"<p>Decision-making statements evaluate conditions and execute code blocks based on whether those conditions are true or false. These include <code>if</code>, <code>if-else</code>, <code>if-else-if</code> ladder, <code>nested if</code>, <code>switch</code>, and the <code>ternary operator</code>.</p>"},{"location":"java/fundamentals/control-statements/#if-statement","title":"if Statement","text":"<p>It is simplest decision-making statement. The <code>if</code> statement executes a block of code only if a specified condition is true.</p> <p>Syntax: </p><pre><code>if (condition) {\n    // code executes if condition is true\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n    B -- True --&gt; C[Execute if block]\n    C --&gt; D([End])\n    B -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int age = 18;\n\nif (age &gt;= 18) {\n    System.out.println(\"You are eligible to vote\");\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>The condition must be a boolean expression</li> <li>Curly braces <code>{}</code> are optional for single statements but recommended for clarity</li> <li>If condition is false, the code block is skipped entirely. The code block executes only if the condition is true</li> </ul>"},{"location":"java/fundamentals/control-statements/#if-else-statement","title":"if-else Statement","text":"<p>The <code>if-else</code> statement provides an alternative path of execution when the condition is false.</p> <p>Syntax: </p><pre><code>if (condition) {\n    // executes if condition is true\n} else {\n    // executes if condition is false\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n    B -- True --&gt; C[Execute if block]\n    B -- False --&gt; E[Execute else block]\n    C --&gt; D([End])\n    E --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int temperature = 25;\n\nif (temperature &gt; 30) {\n    System.out.println(\"It's hot outside.\");\n} else {\n    System.out.println(\"The weather is pleasant.\");\n}\n</code></pre><p></p> <p>Key Points</p> <ul> <li>Exactly one block (either if or else) will execute</li> </ul>"},{"location":"java/fundamentals/control-statements/#if-else-if-ladder","title":"if-else-if Ladder","text":"<p>The <code>if-else-if</code> ladder tests multiple conditions sequentially. The first condition that evaluates to true will execute its corresponding block, and the rest will be skipped.</p> <p>Syntax: </p><pre><code>if (condition1) {\n    // executes if condition1 is true\n} else if (condition2) {\n    // executes if condition1 is false and condition2 is true\n} else if (condition3) {\n    // executes if condition1 and condition2 are false, condition3 is true\n} \n.\n.\n.\nelse {\n    // executes if all conditions are false\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition 1?}\n\n    B -- True --&gt; C[Execute Block 1]\n    B -- False --&gt; D{Condition 2?}\n\n    D -- True --&gt; E[Execute Block 2]\n    D -- False --&gt; F{Condition 3?}\n\n    F -- True --&gt; G[Execute Block 3]\n    F -- False --&gt; H[Execute Default Block]\n\n    C --&gt; I([End])\n    E --&gt; I\n    G --&gt; I\n    H --&gt; I\n</code></pre><p></p> <p>Example: </p><pre><code>int score = 85;\nif (score &gt;= 90) {\n    System.out.println(\"Grade: A\");\n} else if (score &gt;= 80) {\n    System.out.println(\"Grade: B\");\n} else if (score &gt;= 70) {\n    System.out.println(\"Grade: C\");\n} else if (score &gt;= 60) {\n    System.out.println(\"Grade: D\");\n} else {\n    System.out.println(\"Grade: F\");\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>Conditions are evaluated from top to bottom   </li> <li>Only the first true condition's block executes</li> <li>The final <code>else</code> is optional but provides a default case</li> <li>Execution stops after the first match</li> </ul>"},{"location":"java/fundamentals/control-statements/#nested-if-statements","title":"Nested if Statements","text":"<p>Nested <code>if</code> statements are <code>if</code> statements inside other <code>if</code> statements, allowing for complex decision-making logic.</p> <p>Syntax: </p><pre><code>if (condition1) {\n    if (condition2) {\n        // block A\n    } else {\n        // block B\n    }\n} else {\n    // block C\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition 1?}\n\n    B -- True --&gt; C{Condition 2?}\n    B -- False --&gt; H[Execute Block C]\n\n    C -- True --&gt; D[Execute Block A]\n    C -- False --&gt; E[Execute Block B]\n\n    D --&gt; F([End])\n    E --&gt; F\n    H --&gt; F\n</code></pre><p></p> <p>Example: </p><pre><code>int age = 25;\nboolean hasLicense = true;\n\nif (age &gt;= 18) {\n    if (hasLicense) {\n        System.out.println(\"You can drive\");\n    } else {\n        System.out.println(\"You need a license to drive\");\n    }\n} else {\n    System.out.println(\"You are too young to drive\");\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>C an nest to any depth, but deep nesting reduces readability</li> <li>Each <code>if</code> can have its own <code>else</code> clause</li> <li>Consider refactoring deeply nested conditions using logical operators</li> </ul>"},{"location":"java/fundamentals/control-statements/#switch-statement","title":"switch Statement","text":"<p>The <code>switch</code> statement allows multi-way branching based on the value of an expression. It's an alternative to long <code>if-else-if</code> ladders.</p> <p>Syntax: </p><pre><code>switch (expression) {\n    case value1:\n        // code for value1\n        break;\n    case value2:\n        // code for value2\n        break;\n    case value3:\n        // code for value3\n        break;\n    .\n    .\n    .\n    default:\n        // code if no case matches\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Evaluate Expression]\n    B --&gt; C{Match Case 1?}\n\n    C -- Yes --&gt; D[Execute Block 1]\n    C -- No --&gt; E{Match Case 2?}\n\n    E -- Yes --&gt; F[Execute Block 2]\n    E -- No --&gt; G{Match Case 3?}\n\n    G -- Yes --&gt; H[Execute Block 3]\n    G -- No --&gt; I[Execute Default Block]\n\n    D --&gt; J([End])\n    F --&gt; J\n    H --&gt; J\n    I --&gt; J\n</code></pre><p></p> <p>Example: </p><pre><code>int day = 3;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    case 4:\n        System.out.println(\"Thursday\");\n        break;\n    case 5:\n        System.out.println(\"Friday\");\n        break;\n    case 6:\n        System.out.println(\"Saturday\");\n        break;\n    case 7:\n        System.out.println(\"Sunday\");\n        break;\n    default:\n        System.out.println(\"Invalid day\");\n}\n</code></pre><p></p> <p>Key Points: </p> <ul> <li>Switch works with <ul> <li><code>byte</code>, <code>short</code>, <code>int</code>, <code>char</code></li> <li><code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code> (wrapper classes)</li> <li><code>String</code> (Java 7+) and <code>enum</code> types</li> </ul> </li> <li>The <code>break</code> statement is crucial to prevent fall-through behavior</li> <li>Fall-through occurs when <code>break</code> is omitted, causing execution to continue into the next case</li> <li>The <code>default</code> case is optional but recommended for handling unexpected values</li> <li>Multiple cases can share the same code block</li> </ul> <p>Example of Intentional Fall-through: </p><pre><code>int month = 2;\nint days;\nswitch (month) {\n    case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n        days = 31;\n        break;\n    case 4: case 6: case 9: case 11:\n        days = 30;\n        break;\n    case 2:\n        days = 28;\n        break;\n    default:\n        days = 0;\n}\n</code></pre> <p></p>"},{"location":"java/fundamentals/control-statements/#advanced-switch-features-java-12","title":"Advanced switch Features (Java 12+):","text":"<p>Switch expressions are an enhanced form of switch introduced in Java 12 (preview) and made standard in Java 14. They can return values and use arrow syntax.</p> <p>Syntax: </p><pre><code>result = switch (expression) {\n    case value1 -&gt; result1;\n    case value2 -&gt; result2;\n    case value3 -&gt; result3;\n    default -&gt; defaultResult;\n};\n</code></pre><p></p> <p>Example: </p><pre><code>int dayOfWeek = 3;\n\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -&gt; \"Weekday\";\n    case 6, 7 -&gt; \"Weekend\";\n    default -&gt; \"Invalid day\";\n};\n\nSystem.out.println(dayType);\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#using-yield-for-complex-cases","title":"Using yield for Complex Cases:","text":"<pre><code>int score = 85;\n\nString grade = switch (score / 10) {\n    case 10, 9 -&gt; \"A\";\n    case 8 -&gt; \"B\";\n    case 7 -&gt; \"C\";\n    case 6 -&gt; \"D\";\n    default -&gt; {\n        if (score &lt; 0 || score &gt; 100) {\n            yield \"Invalid score\";\n        }\n        yield \"F\";\n    }\n};\n\nSystem.out.println(\"Grade: \" + grade);\n</code></pre> <p>Key Points:</p> <ul> <li>No fall-through; each case is independent</li> <li>Can return values directly</li> <li>Multiple values can be combined with commas</li> <li>Use <code>yield</code> for complex expressions in blocks</li> <li>More concise and less error-prone than traditional switch</li> </ul>"},{"location":"java/fundamentals/control-statements/#ternary-operator","title":"Ternary Operator","text":"<p>A concise way to write simple <code>if-else</code> statements in a single line.</p> <p>Syntax: </p><pre><code>variable = (condition) ? expressionIfTrue : expressionIfFalse;\n</code></pre><p></p> <p>Example: </p><pre><code>int a = 10, b = 20;\nint max = (a &gt; b) ? a : b;\nSystem.out.println(\"Maximum: \" + max);\n\n// Can be nested (not recommended for readability)\nint x = 5;\nString result = (x &gt; 0) ? \"Positive\" : (x &lt; 0) ? \"Negative\" : \"Zero\";\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#looping-statements","title":"Looping Statements","text":"<p>Loops allow you to execute a block of code repeatedly based on a condition. Java provides <code>for</code> loop, <code>while</code> loop, <code>do-while</code> loop, and enhanced <code>for-each</code> loop.</p>"},{"location":"java/fundamentals/control-statements/#for-loop","title":"for Loop","text":"<p>The <code>for</code> loop is used when you know in advance how many times you want to execute a statement or block.</p> <p>Syntax: </p><pre><code>for (initialization; condition; update) {\n    // code to be executed\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Initialization]\n    B --&gt; C{Condition?}\n\n    C -- True --&gt; D[Execute Loop Body]\n    D --&gt; E[Update Expression]\n    E --&gt; C\n\n    C -- False --&gt; F([End])\n</code></pre><p></p> <p>Example: </p><pre><code>// Print numbers 1 to 10\nfor (int i = 1; i &lt;= 10; i++) {\n    System.out.println(i);\n}\n</code></pre><p></p> <p>Components:</p> <ol> <li>Initialization: Executed once at the start (e.g., int i = 1)</li> <li>Condition: Checked before each iteration (e.g., i &lt;= 10)</li> <li>Update: Executed after each iteration (e.g., i++)</li> </ol> <p>Execution Flow:</p> <ol> <li>Initialization executes once at the beginning</li> <li>Condition is evaluated before each iteration</li> <li>If condition is true, loop body executes</li> <li>Update statement executes after each iteration</li> <li>Process repeats from step 2</li> </ol> <p>Multiple Variables: </p><pre><code>for (int i = 0, j = 10; i &lt; j; i++, j--) {\n    System.out.println(\"i: \" + i + \", j: \" + j);\n}\n</code></pre><p></p> <p>Infinite Loop: </p><pre><code>for (;;) {\n    // This loop runs forever\n    // Use break to exit\n}\n</code></pre><p></p>"},{"location":"java/fundamentals/control-statements/#while-loop","title":"while Loop","text":"<p>The <code>while</code> loop executes a block of code as long as a specified condition is true. It's a pre-test loop (condition checked before execution).</p> <p>Syntax: </p><pre><code>while (condition) {\n    // code to be executed\n}\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B{Condition?}\n\n    B -- True --&gt; C[Execute Loop Body]\n    C --&gt; B\n\n    B -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int count = 1;\nwhile (count &lt;= 5) {\n    System.out.println(\"Count: \" + count);\n    count++;\n}\n\n// Reading input until a sentinel value\nScanner scanner = new Scanner(System.in);\nint number = scanner.nextInt();\nwhile (number != -1) {\n    System.out.println(\"You entered: \" + number);\n    number = scanner.nextInt();\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>Condition is evaluated before each iteration</li> <li>If the condition is initially false, the loop body never executes</li> <li>Must ensure the condition eventually becomes false to avoid infinite loops</li> <li>Useful when the number of iterations is unknown</li> </ul>"},{"location":"java/fundamentals/control-statements/#do-while-loop","title":"do-while Loop","text":"<p>The <code>do-while</code> loop is similar to <code>while</code>, but it's a post-test loop (condition checked after execution). It guarantees at least one execution.</p> <p>Syntax: </p><pre><code>do {\n    // code to be executed\n} while (condition);\n</code></pre><p></p> <p>Flow Chart </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TD\n    A([Start]) --&gt; B[Execute Loop Body]\n    B --&gt; C{Condition?}\n\n    C -- True --&gt; B\n    C -- False --&gt; D([End])\n</code></pre><p></p> <p>Example: </p><pre><code>int count = 1;\n\ndo {\n    System.out.println(\"Count: \" + count);\n    count++;\n} while (count &lt;= 5);\n</code></pre><p></p> <p>Key Points:</p> <ul> <li><code>do-while</code> executes at least once regardless of condition</li> <li>Condition checked after the loop body</li> <li><code>while</code> may not execute at all if condition is initially false</li> <li>Useful for input validation and menu-driven programs</li> </ul>"},{"location":"java/fundamentals/control-statements/#enhanced-for-loop-for-each","title":"Enhanced for Loop (<code>for-each</code>)","text":"<p>The enhanced <code>for</code> loop (introduced in Java 5) provides a simpler way to iterate over arrays and collections.</p> <p>Syntax: </p><pre><code>for (dataType variable : arrayOrCollection) {\n    // code using variable\n}\n</code></pre><p></p> <p>Array Example:: </p><pre><code>int[] numbers = {1, 2, 3, 4, 5};\n\nfor (int num : numbers) {\n    System.out.println(num);\n}\n</code></pre><p></p> <p>Collection Example: </p><pre><code>List&lt;String&gt; fruits = Arrays.asList(\"Apple\", \"Banana\", \"Cherry\");\n\nfor (String fruit : fruits) {\n    System.out.println(fruit);\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>Primarily used for read-only traversal</li> <li>Cannot modify the structure of an array or collection (no add/remove operations)</li> <li>Cleaner and less error-prone than a traditional <code>for</code> loop</li> <li>No direct access to the index</li> <li>Works with:<ul> <li>Arrays</li> <li>Any class implementing <code>Iterable</code></li> </ul> </li> </ul> <p>Limitations:</p> <ul> <li>Cannot modify primitive array elements (the loop variable is a copy; reassignment does not affect the original array)</li> <li>Cannot directly track the index during iteration</li> <li>Can only iterate forward in single-step increments</li> <li>Cannot iterate over multiple arrays/collections simultaneously</li> <li>Cannot safely remove elements from a collection during iteration (may cause <code>ConcurrentModificationException</code>)</li> </ul>"},{"location":"java/fundamentals/control-statements/#nested-loops","title":"Nested Loops","text":"<p>Nested loops are loops inside other loops. The inner loop completes all its iterations for each iteration of the outer loop.</p> <p>Example: </p><pre><code>for (int i = 1; i &lt;= 10; i++) {\n    for (int j = 1; j &lt;= 10; j++) {\n        System.out.printf(\"%4d\", i * j);\n    }\n    System.out.println();\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>Time complexity multiplies (O(n\u00b2) for two nested loops)</li> <li>Useful for multi-dimensional data structures</li> <li>Can nest any type of loop (<code>for</code>, <code>while</code>, <code>do-while</code>)</li> </ul>"},{"location":"java/fundamentals/control-statements/#jump-statements","title":"Jump Statements","text":"<p>Jump statements transfer control to another part of the program. These include <code>break</code>, <code>continue</code>, and <code>return</code>.</p>"},{"location":"java/fundamentals/control-statements/#break-statement","title":"break Statement","text":"<p>The <code>break</code> statement terminates the current loop or switch statement and transfers control to the statement immediately following the loop/switch.</p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\n\nflowchart TB\n    A([Start]) --&gt; B{Loop Condition?}\n\n    B -- True --&gt; C{Break Condition?}\n    C -- Yes --&gt; F([Exit Loop])\n    C -- No --&gt; D[Execute Remaining Loop Body]\n    D --&gt; B\n\n    B -- False --&gt; F\n</code></pre><p></p> <p>In Loops: </p><pre><code>// Find first even number\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i % 2 == 0) {\n        System.out.println(\"First even number: \" + i);\n        break; // Exit loop\n    }\n}\n</code></pre><p></p> <p>In switch: </p><pre><code>int day = 3;\n\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break; // Exit switch\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break; // Exit switch\n    default:\n        System.out.println(\"Other day\");\n}\n</code></pre><p></p> <p>In Nested Loops: </p><pre><code>// Break only exits the innermost loop\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) {\n            break; // Only exits inner loop\n        }\n        System.out.println(\"i: \" + i + \", j: \" + j);\n    }\n}\n</code></pre><p></p> <ul> <li>If <code>break</code> condition becomes true \u2192 loop terminates immediately.</li> <li>Control moves outside the loop.</li> </ul>"},{"location":"java/fundamentals/control-statements/#continue-statement","title":"continue Statement","text":"<p>The <code>continue</code> statement skips the current iteration of a loop and proceeds to the next iteration.</p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '12px' }} }%%\nflowchart TD\n    A([Start]) --&gt; B{Loop Condition?}\n\n    B -- True --&gt; C{Continue Condition?}\n    C -- Yes --&gt; B\n    C -- No --&gt; D[Execute Remaining Loop Body]\n    D --&gt; B\n\n    B -- False --&gt; E([End])\n</code></pre><p></p> <p>Example: </p><pre><code>// Print odd numbers from 1 to 10\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i % 2 == 0) {\n        continue; // Skip even numbers\n    }\n    System.out.println(i);\n}\n</code></pre><p></p> <p>In while Loop: </p><pre><code>int i = 0;\n\nwhile (i &lt; 10) {\n    i++;\n    if (i % 2 == 0) {\n        continue; // Skip even numbers\n    }\n    System.out.println(i);\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>If <code>continue</code> condition is true \u2192 skip remaining statements</li> <li>Control jumps to next iteration</li> <li>In <code>for</code> loop: jumps to the update statement</li> <li>In <code>while</code>/<code>do-while</code>: jumps to the condition check</li> <li>Loop does NOT terminate</li> <li>Only affects the innermost loop in nested loops</li> </ul>"},{"location":"java/fundamentals/control-statements/#return-statement","title":"return Statement","text":"<p>The <code>return</code> statement exits from the current method and optionally returns a value to the caller.</p> <p>Syntax: </p><pre><code>return; // For void methods\nreturn value; // For methods returning a value\n</code></pre><p></p> <p>Flow Chart: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\nflowchart TD\n    A([Method Start]) --&gt; B{Condition?}\n\n    B -- True --&gt; C[Return Value]\n    B -- False --&gt; D[Another Return Value]\n\n    C --&gt; E([Method End])\n    D --&gt; E\n</code></pre><p></p> <p>Example: </p><pre><code>public int findMax(int a, int b) {\n    if (a &gt; b) {\n        return a; // Exit method and return a\n    } else {\n        return b; // Exit method and return b\n    }\n}\n\npublic void printMessage(String message) {\n    if (message == null) {\n        return; // Exit method early\n    }\n    System.out.println(message);\n}\n</code></pre><p></p> <p>Key Points:</p> <ul> <li><code>return</code> immediately exits the method</li> <li>Control goes back to the caller</li> <li>No further code executes in that method</li> <li>Can be used for early termination</li> <li>Must return appropriate type for non-void methods</li> </ul>"},{"location":"java/fundamentals/control-statements/#labeled-break-and-continue","title":"Labeled break and continue","text":"<p>Labels allow you to break out of or continue with outer loops in nested loop structures.</p> <p>Syntax: </p><pre><code>labelName:\nfor (...) {\n    for (...) {\n        break labelName; // Breaks out of labeled loop\n        continue labelName; // Continues with labeled loop\n    }\n}\n</code></pre><p></p> <p>Labeled break Example: </p><pre><code>outerLoop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i == 2 &amp;&amp; j == 2) {\n            System.out.println(\"Breaking out of outer loop\");\n            break outerLoop; // Exits both loops\n        }\n        System.out.println(\"i: \" + i + \", j: \" + j);\n    }\n}\nSystem.out.println(\"Outside loops\");\n</code></pre><p></p> <p>Output: </p><pre><code>i: 1, j: 1\ni: 1, j: 2\ni: 1, j: 3\ni: 2, j: 1\nBreaking out of outer loop\nOutside loops\n</code></pre><p></p> <p>Labeled continue Example: </p><pre><code>outerLoop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (j == 2) {\n            continue outerLoop; // Skip to next iteration of outer loop\n        }\n        System.out.println(\"i: \" + i + \", j: \" + j);\n    }\n}\n</code></pre><p></p> <p>Output: </p><pre><code>i: 1, j: 1\ni: 2, j: 1\ni: 3, j: 1\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>Use sparingly; can reduce code readability</li> <li>Useful for complex nested loop scenarios</li> <li>Label must be immediately before the loop</li> <li>Provides better control than using flags</li> </ul>"},{"location":"java/fundamentals/control-statements/#common-mistakes","title":"Common Mistakes","text":"<ol> <li>Forgetting break in switch statements leads to fall-through behavior: <pre><code>// Bug: will print multiple days\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n    case 2:\n        System.out.println(\"Tuesday\");  // executes even when day is 1\n}\n</code></pre></li> <li> <p>Semicolon After if/while/for </p><pre><code>if (x &gt; 10); // Semicolon here!\n{\n    System.out.println(\"x is greater than 10\");\n}\n// This block always executes\n</code></pre><p></p> </li> <li> <p>Using assignment instead of comparison: </p><pre><code>if (x = 5) { }  // Compilation error in Java (good!)\n</code></pre><p></p> </li> <li> <p>Off-by-one errors in loops: </p><pre><code>// Bug: misses last element\nfor (int i = 0; i &lt; array.length - 1; i++) { }\n\n// Correct\nfor (int i = 0; i &lt; array.length; i++) { }\n</code></pre><p></p> </li> <li> <p>Modifying loop variables incorrectly: </p><pre><code>// Bug: infinite loop\nfor (int i = 0; i &lt; 10; i--) { }\n\nint i = 0;\nwhile (i &lt; 10) {\n    System.out.println(i);\n    // Forgot to increment i\n}\n</code></pre><p></p> </li> <li> <p>Wrong Loop Choice </p><pre><code>String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n\nfor (String name : names) {\n    // Can't access index here\n}\n</code></pre><p></p> </li> <li> <p>Modifying Collection During Enhanced for Loop </p><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"A\", \"B\", \"C\"));\n\nfor (String item : list) {\n    if (item.equals(\"B\")) {\n        list.remove(item); // ConcurrentModificationException\n    }\n}\n</code></pre><p></p> </li> <li> <p>Floating-Point Comparison </p><pre><code>double a = 0.1 + 0.2;\nif (a == 0.3) { // May not work due to precision issues\n    System.out.println(\"Equal\");\n}\n</code></pre><p></p> </li> <li> <p>Comparing strings with == instead of equals(): </p><pre><code>// Wrong\nif (str == \"hello\") { }\n\n// Correct\nif (str.equals(\"hello\")) { }\n</code></pre><p></p> </li> </ol>"},{"location":"java/fundamentals/control-statements/#best-practices","title":"Best Practices","text":"<ol> <li>Always use braces for if/else and loops, even for single statements, to prevent bugs during maintenance.</li> <li>Avoid deep nesting of <code>if</code> statements. Consider refactoring into separate methods or using early returns.</li> <li>Use meaningful conditions and avoid magic numbers: <pre><code>   // Bad\nif (status == 1) { }\n\n// Good\nfinal int ACTIVE = 1;\nif (status == ACTIVE) { }\n</code></pre></li> <li>Choose the right loop based on your needs. Use <code>for</code> when iterations are known, <code>while</code> when they depend on conditions, and <code>for-each</code> for simple traversal.</li> <li>Be cautious with infinite loops and always ensure a proper exit condition.</li> </ol>"},{"location":"java/fundamentals/control-statements/#performance-considerations","title":"Performance Considerations","text":"<p>The choice between different control structures can impact performance. <code>for-each</code> loops are generally as fast as traditional <code>for</code> loops. <code>Switch</code> statements with many cases can be optimized by the JVM into jump tables, making them faster than equivalent <code>if-else</code> chains for certain scenarios.</p>"},{"location":"java/oops/","title":"OOPs","text":""},{"location":"java/oops/#object-oriented-programming-oop","title":"Object-Oriented Programming (OOP)","text":""},{"location":"java/oops/classes-and-objects/","title":"Classes and Objects","text":""},{"location":"java/strings/basics/","title":"Basics","text":""},{"location":"java/strings/basics/#strings-in-java","title":"Strings in Java","text":""},{"location":"java/strings/basics/#introduction","title":"Introduction","text":"<p>In Java, <code>String</code> is one of the most fundamental and widely used classes, representing an immutable sequence of characters. Unlike primitive types, <code>String</code> is a reference type that provides powerful methods for text manipulation, comparison, and transformation. Strings are ubiquitous in Java applications\u2014from user input and file I/O to network communication and data serialization.</p> <p>Understanding <code>String</code> deeply is crucial for Java developers because it impacts code correctness, performance, and memory efficiency. The immutability of strings, the string pool optimization, and the distinction between <code>String</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> are key concepts.</p>"},{"location":"java/strings/basics/#creating-strings","title":"Creating Strings","text":"<p>There are multiple ways to create <code>String</code> objects in Java:</p> <ol> <li> <p>String Literals </p><pre><code>String s1 = \"Hello\";\nString s2 = \"Hello\";\n// s1 == s2 is true (same reference in string pool)\n</code></pre><p></p> </li> <li> <p>Using <code>new</code> Keyword </p><pre><code>String s3 = new String(\"Hello\");\nString s4 = new String(\"Hello\");\n// s3 == s4 is false (different objects)\n// s3.equals(s4) is true (same content) \n</code></pre><p></p> </li> <li> <p>Using <code>String.valueOf()</code> </p><pre><code>int num = 123;\nString s5 = String.valueOf(num);  // \"123\"\nString s6 = String.valueOf(true); // \"true\"\nString s7 = String.valueOf(3.14); // \"3.14\"\n</code></pre><p></p> </li> <li> <p>Using <code>String.format()</code> </p><pre><code>String s8 = String.format(\"Name: %s, Age: %d\", \"Alice\", 25);\n// \"Name: Alice, Age: 25\"\n</code></pre><p></p> </li> <li> <p>Text Blocks (Java 15+) </p><pre><code>String json = \"\"\"\n    {\n        \"name\": \"Alice\",\n        \"age\": 25\n    }\n    \"\"\";\n</code></pre><p></p> </li> </ol>"},{"location":"java/strings/basics/#string-pool-intern","title":"String Pool &amp; <code>intern()</code>","text":"<p>The <code>String Pool</code> (or String Intern Pool) is a special memory region in the Java heap where string literals are stored. When you create a string literal, the JVM checks if an identical string already exists in the pool. If it does, the JVM returns a reference to the existing string instead of creating a new object.</p> <p>Example with <code>intern()</code>: </p><pre><code>String s1 = \"Hello\";           // In string pool\nString s2 = new String(\"Hello\"); // In heap (not pool)\nString s3 = s2.intern();       // Returns reference from pool\n\nSystem.out.println(s1 == s2);  // false (different objects)\nSystem.out.println(s1 == s3);  // true (same pool reference)\nSystem.out.println(s1.equals(s2)); // true (same content)\n</code></pre><p></p> <p>Memory Layout Visualization: </p><pre><code>%%{init: {'themeVariables': { 'fontSize': '10px' }} }%%\n\nflowchart LR\n\n    subgraph Stack Memory\n        S1[s1]\n        S2[s2]\n        S3[s3]\n    end\n\n    subgraph Heap Memory\n        subgraph String Constant Pool\n            P[\"Hello (pooled object)\"]\n        end\n\n        H[\"Hello (new object)\"]\n    end\n\n    S1 --&gt; P\n    S2 --&gt; H\n    S3 --&gt; P\n\n</code></pre><p></p> <p>Key Points:</p> <ul> <li>String literals are automatically interned</li> <li><code>new String()</code> creates a new object on the heap</li> <li><code>intern()</code> returns the canonical representation from the pool</li> <li>Use literals when possible to leverage the pool</li> </ul>"},{"location":"java/strings/immutability/","title":"Immutability","text":""},{"location":"java/strings/immutability/#strings-immutability","title":"Strings Immutability","text":""},{"location":"java/strings/immutability/#what-is-immutability","title":"What is Immutability?","text":"<p>Immutability means that once a <code>String</code> object is created, its internal state (the character sequence it holds) cannot be changed. Any operation that appears to modify a string actually creates a new String object with the modified content, leaving the original untouched.</p> <pre><code>String str = \"Hello\";\nstr.concat(\" World\");  // Creates new String, but str still points to \"Hello\"\nSystem.out.println(str);  // Output: \"Hello\" (unchanged!)\n\nString newStr = str.concat(\" World\");  // Must capture the new object\nSystem.out.println(newStr);  // Output: \"Hello World\"\n</code></pre>"},{"location":"java/strings/immutability/#internal-implementation","title":"Internal Implementation","text":"<p>Internally, a <code>String</code> is backed by a character array. Here's a simplified view of the <code>String</code> class:</p> <pre><code>public final class String {\n    private final char[] value;  // Java 8 and earlier\n    // Or: private final byte[] value; // Java 9+ (compact strings)\n\n    private final int hash;  // Cached hashcode\n\n    // No setter methods!\n    // All methods that \"modify\" return new String objects\n}\n</code></pre> <p>Key points:</p> <ul> <li>The <code>value</code> array is <code>private final</code> - it can't be reassigned after initialization</li> <li>The <code>String</code> class is <code>final</code> - can't be subclassed to add mutable behavior</li> <li>No public methods exist to modify the internal character array</li> </ul>"},{"location":"java/strings/immutability/#why-are-strings-immutable","title":"Why Are Strings Immutable?","text":""},{"location":"java/strings/immutability/#1-string-pool-memory-optimization","title":"1. String Pool (Memory Optimization)","text":"<p>The JVM maintains a String Pool where identical string literals are reused:</p> <pre><code>String s1 = \"Java\";\nString s2 = \"Java\";\nString s3 = \"Java\";\n\n// All three variables point to THE SAME object in memory\nSystem.out.println(s1 == s2);  // true\nSystem.out.println(s2 == s3);  // true\n</code></pre> <p>Memory layout: </p><pre><code>flowchart LR\n\n    %% Stack Variables\n    subgraph Stack\n        S1[s1]\n        S2[s2]\n        S3[s3]\n    end\n\n    %% Heap - String Pool\n    subgraph Heap Memory\n        subgraph String Pool\n            J[\"Java @ 0x100\"]\n        end\n    end\n\n    S1 --&gt; J\n    S2 --&gt; J\n    S3 --&gt; J\n</code></pre><p></p> <p>If strings were mutable, changing <code>s1</code> would affect <code>s2</code> and <code>s3</code> - a nightmare! Immutability makes this safe sharing possible, saving memory.</p>"},{"location":"java/strings/immutability/#2-security","title":"2. Security","text":"<p>Strings are used for sensitive data like:</p> <ul> <li>File paths</li> <li>Network connections</li> <li>Database queries</li> <li>User credentials</li> </ul> <p>Security scenario: </p><pre><code>String password = \"secret123\";\n\nif (authenticate(password)) {\n    // Without immutability, password could be changed here\n    // by reference manipulation from malicious code\n    grantAccess();  // We know password hasn't changed\n}\n</code></pre><p></p>"},{"location":"java/strings/immutability/#3-thread-safety","title":"3. Thread Safety","text":"<p>Immutable objects are inherently thread-safe - no synchronization needed! </p><pre><code>public class ThreadSafeExample {\n    private String sharedString = \"Shared Data\";\n\n    // Multiple threads can read this safely without locks\n    public String getData() {\n        return sharedString;  // No synchronization needed!\n    }\n}\n</code></pre><p></p> <p>Compare with mutable alternative: </p><pre><code>public class NotThreadSafe {\n    private StringBuilder mutableString = new StringBuilder(\"Data\");\n\n    // REQUIRES synchronization to be safe\n    public synchronized String getData() {\n        return mutableString.toString();\n    }\n\n    public synchronized void setData(String data) {\n        mutableString.setLength(0);\n        mutableString.append(data);\n    }\n}\n</code></pre><p></p>"},{"location":"java/strings/immutability/#4-hashcode-caching","title":"4. Hashcode Caching","text":"<p>Since strings can't change, their hashcode can be computed once and cached: </p><pre><code>public final class String {\n    private int hash;  // Default to 0\n\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 &amp;&amp; value.length &gt; 0) {\n            // Compute only once\n            h = calculateHash();\n            hash = h;\n        }\n        return h;\n    }\n}\n</code></pre><p></p> <p>This makes strings extremely efficient as HashMap/HashSet keys: </p><pre><code>Map&lt;String, User&gt; userCache = new HashMap&lt;&gt;();\nuserCache.put(\"john@email.com\", johnUser);  // hashCode computed once\n\n// Later lookups are very fast - no hash recomputation\nUser john = userCache.get(\"john@email.com\");\n</code></pre><p></p>"},{"location":"java/strings/immutability/#5-class-loading","title":"5. Class Loading","text":"<p>Class and method names are strings. Immutability prevents security issues: </p><pre><code>String className = \"com.example.TrustedClass\";\nClass&lt;?&gt; cla = Class.forName(className);\n// If String were mutable, className could be changed to load malicious code!\n</code></pre><p></p>"},{"location":"java/strings/immutability/#demonstrating-immutability","title":"Demonstrating Immutability","text":"<p>Example 1: Concatenation Creates New Objects </p><pre><code>String original = \"Hello\";\nString modified = original + \" World\";\n\nSystem.out.println(original);   // \"Hello\" (unchanged)\nSystem.out.println(modified);   // \"Hello World\" (new object)\nSystem.out.println(original == modified);  // false (different objects)\n</code></pre><p></p> <p>Memory layout: </p><pre><code>flowchart LR\n\n    %% Stack Section\n    subgraph Stack\n        O[original]\n        M[modified]\n    end\n\n    %% Heap Section\n    subgraph Heap Memory\n        subgraph String Pool\n            H[\"Hello\"]\n            W[\" World\"]\n        end\n\n        HW[\"Hello World\"]\n    end\n\n    O --&gt; H\n    M --&gt; HW\n\n</code></pre><p></p> <p>Example 2: String Methods Return New Strings </p><pre><code>String s = \"  Java Programming  \";\n\nString trimmed = s.trim();\nString upper = s.toUpperCase();\nString replaced = s.replace(\"Java\", \"Python\");\n\nSystem.out.println(s);         // \"  Java Programming  \" (UNCHANGED)\nSystem.out.println(trimmed);   // \"Java Programming\"\nSystem.out.println(upper);     // \"  JAVA PROGRAMMING  \"\nSystem.out.println(replaced);  // \"  Python Programming  \"\n</code></pre><p></p> <p>Example 3: Even Array Manipulation Doesn't Change Original </p><pre><code>String str = \"Hello\";\nchar[] chars = str.toCharArray();  // Creates a COPY\n\nchars[0] = 'J';  // Modify the array\n\nSystem.out.println(str);           // \"Hello\" (unchanged!)\nSystem.out.println(new String(chars));  // \"Jello\"\n</code></pre><p></p> <p>Example 4: Reflection Can't Mutate (Well, Almost...) Warning: This is a demonstration of Java internals - NEVER do this in production!</p> <pre><code>String s = \"Hello\";\n\n// Using reflection to access private fields (VERY BAD PRACTICE)\nField valueField = String.class.getDeclaredField(\"value\");\nvalueField.setAccessible(true);\nchar[] value = (char[]) valueField.get(s);\nvalue[0] = 'J';\n\nSystem.out.println(s);  // \"Jello\" (CORRUPTED!)\n\n// This breaks the String pool:\nString s2 = \"Hello\";\nSystem.out.println(s2);  // \"Jello\" (WRONG! Pool is corrupted)\n</code></pre> <p>This demonstrates why the <code>value</code> field is private and why you should never use reflection to modify strings!</p>"},{"location":"java/strings/immutability/#performance-implications","title":"Performance Implications","text":"<p>The Cost of Immutability Problem: String concatenation in loops </p><pre><code>// \u274c VERY INEFFICIENT: O(n\u00b2) complexity\nString result = \"\";\nfor (int i = 0; i &lt; 10000; i++) {\n    result += i + \",\";  // Creates 10,000 intermediate String objects!\n}\n</code></pre><p></p> <p>What happens:</p> <ol> <li>Iteration 1: <code>\"\" + \"0,\"</code> \u2192 new String <code>\"0,\"</code></li> <li>Iteration 2: <code>\"0,\" + \"1,\"</code> \u2192 new String <code>\"0,1,\"</code> (copies \"0,\")</li> <li>Iteration 3: <code>\"0,1,\" + \"2,\"</code> \u2192 new String <code>\"0,1,2,\"</code> (copies \"0,1,\")</li> <li>And so on...</li> </ol> <p>Memory created: </p><pre><code>\"\"\n\"0,\"\n\"0,1,\"\n\"0,1,2,\"\n\"0,1,2,3,\"\n...\n</code></pre> Total characters copied: <code>0 + 2 + 4 + 6 + ... \u2248 n\u00b2/2</code><p></p> <p>The Solution: <code>StringBuilder</code> </p><pre><code>// \u2705 EFFICIENT: O(n) complexity\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 10000; i++) {\n    sb.append(i).append(\",\");\n}\nString result = sb.toString();  // Only ONE String object created at the end\n</code></pre><p></p> <p>How StringBuilder works:</p> <ul> <li>Maintains a mutable character array</li> <li>When capacity is exceeded, creates a larger array and copies</li> <li>Only creates a String when you call toString()</li> </ul>"},{"location":"java/strings/immutability/#compiler-optimizations","title":"Compiler Optimizations","text":"<p>Compile-Time Concatenation The compiler is smart about string literals </p><pre><code>// This code:\nString s = \"Hello\" + \" \" + \"World\";\n\n// Is compiled to:\nString s = \"Hello World\";  // Single literal, no concatenation!\n</code></pre><p></p> <p>Runtime Concatenation (Java 9+) For runtime concatenation, modern Java uses <code>invokedynamic</code>: </p><pre><code>String name = \"Alice\";\nString greeting = \"Hello, \" + name + \"!\";\n\n// Pre-Java 9: Compiled to StringBuilder\nStringBuilder temp = new StringBuilder();\ntemp.append(\"Hello, \").append(name).append(\"!\");\nString greeting = temp.toString();\n\n// Java 9+: Uses invokedynamic with StringConcatFactory\n// More efficient, JVM can optimize further\n</code></pre><p></p>"},{"location":"java/strings/immutability/#best-practices","title":"Best Practices","text":"<p>1. Embrace Immutability for Single Operations </p><pre><code>// \u2705 Fine for single operations\nString result = str.toUpperCase().trim().replace(\" \", \"_\");\n</code></pre><p></p> <p>2. Use StringBuilder for Multiple Modifications </p><pre><code>// \u2705 When building strings in loops\nStringBuilder builder = new StringBuilder();\nfor (Item item : items) {\n    builder.append(item.getName()).append(\", \");\n}\n</code></pre><p></p> <p>3. Leverage the String Pool </p><pre><code>// \u2705 Use literals\nString s1 = \"constant\";\n\n// \u274c Avoid unnecessary object creation\nString s2 = new String(\"constant\");  // Creates extra object!\n</code></pre><p></p> <p>4. Don't Fear Immutability </p><pre><code>// This is FINE - Java optimizes it\nString fileName = basePath + \"/\" + folder + \"/\" + file;\n\n// This is the PROBLEM - loop concatenation\nString csv = \"\";\nfor (int i = 0; i &lt; 10000; i++) {\n    csv += i + \",\";  // \u274c\n}\n</code></pre><p></p>"},{"location":"java/strings/string-comparison/","title":"== VS equlas()","text":""}]}